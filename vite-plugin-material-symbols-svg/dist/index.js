import path from "node:path";
import fs from "node:fs/promises";
import { s as symbolConfig, n as normalizeNums, a as normalizeFills, b as normalizeThemes, u as unique, k as keyOf, c as customKeyOf, d as configureSymbolConfig } from "./config-Pn2OSTF5.js";
import { i } from "./config-Pn2OSTF5.js";
async function exists$1(p) {
  try {
    await fs.access(p);
    return true;
  } catch {
    return false;
  }
}
async function fetchVersions(ctx, versionsFile, iconsTsFile, options) {
  if (await exists$1(versionsFile)) return;
  ctx.info("[material-symbols-svg] Fetching Material Symbols metadata...");
  const metaUrl = "https://fonts.google.com/metadata/icons?key=material_symbols&incomplete=true";
  try {
    const res = await fetch(metaUrl);
    if (!res.ok) {
      const msg = `Failed to fetch metadata: HTTP ${res.status}`;
      if (options.strict) ctx.error(`[material-symbols-svg] ${msg}`);
      else ctx.warn(`[material-symbols-svg] ${msg}`);
      return;
    }
    let txt = await res.text();
    if (txt.startsWith(")]}'")) {
      const i2 = txt.indexOf("\n");
      if (i2 !== -1) txt = txt.substring(i2 + 1);
    }
    let parsed;
    try {
      parsed = JSON.parse(txt);
    } catch (e) {
      const msg = "Failed to parse metadata JSON";
      if (options.strict) ctx.error(`[material-symbols-svg] ${msg}`);
      else ctx.warn(`[material-symbols-svg] ${msg}`);
      parsed = null;
    }
    if (parsed && Array.isArray(parsed.icons)) {
      const versions = {};
      for (const icon of parsed.icons) {
        const famsAny = icon && icon["unsupported_families"];
        const families = Array.isArray(famsAny) ? famsAny : [];
        let skip = false;
        for (const fam of families) {
          if (String(fam).toLowerCase().includes("symbols")) {
            skip = true;
            break;
          }
        }
        if (skip) continue;
        const name = String((icon == null ? void 0 : icon.name) || "");
        if (!name) continue;
        versions[name] = icon == null ? void 0 : icon.version;
      }
      const sorted = Object.fromEntries(Object.entries(versions).sort((a, b) => a[0].localeCompare(b[0])));
      const versionsContent = JSON.stringify(sorted, null, 2);
      await fs.writeFile(versionsFile, versionsContent);
      try {
        const names = Object.keys(sorted);
        const union = names.map((n) => `'${n.replace(/'/g, "\\'")}'`).join(" | ");
        const banner = `// This file is auto-generated by vite-plugin-material-symbols-svg
// Do not edit manually.
`;
        const content = `${banner}export type MaterialSymbolIcon = ${union};
`;
        let existing = "";
        try {
          existing = await fs.readFile(iconsTsFile, "utf-8");
        } catch {
        }
        if (existing !== content) {
          await fs.writeFile(iconsTsFile, content);
          const now = /* @__PURE__ */ new Date();
          await fs.utimes(iconsTsFile, now, now).catch(() => {
          });
        }
      } catch (e) {
        const msg = e instanceof Error ? e.message : String(e);
        ctx.warn(`[material-symbols-svg] Failed to write icons.ts: ${msg}`);
      }
    } else {
      await fs.writeFile(versionsFile, txt);
    }
  } catch (e) {
    const msg = e instanceof Error ? e.message : String(e);
    if (options.strict) ctx.error(`[material-symbols-svg] Metadata prefetch failed: ${msg}`);
    else ctx.warn(`[material-symbols-svg] Metadata prefetch failed: ${msg}`);
  }
}
async function exists(p) {
  try {
    await fs.access(p);
    return true;
  } catch {
    return false;
  }
}
function axesString(weight, filled) {
  const w = weight === 400 ? "" : `wght${weight}`;
  const f = filled === 0 ? "" : `fill${filled}`;
  const s = `${w}${f}`;
  return s.length ? s : "default";
}
function buildSymbolUrl(theme, icon, axes, size) {
  const themePart = theme || "";
  return `https://fonts.gstatic.com/s/i/short-term/release/materialsymbols${themePart}/${icon}/${axes}/${size}px.svg`;
}
function toFilename(icon, filled, weight, size) {
  const w = Number.isFinite(weight) ? `.w${weight}` : "";
  const s = Number.isFinite(size) ? `.s${size}` : "";
  const fillPart = filled === 1 ? "-fill" : "";
  return `${icon}${fillPart}${w}${s}.svg`;
}
async function removeIfNotSvg(file) {
  try {
    const str = await fs.readFile(file, "utf8");
    const ok = str.startsWith("<svg") && str.includes("</svg>");
    if (!ok) await fs.rm(file, { force: true });
  } catch {
  }
}
async function withConcurrency(items, limit, worker) {
  const ret = [];
  let idx = 0;
  const run = async () => {
    while (idx < items.length) {
      const i2 = idx++;
      ret[i2] = await worker(items[i2], i2);
    }
  };
  const runners = Array.from({ length: Math.min(limit, items.length) }, run);
  await Promise.all(runners);
  return ret;
}
async function downloadSymbols(tasks, concurrency, logger) {
  let failed = 0;
  let skipped = 0;
  let saved = 0;
  await withConcurrency(tasks, concurrency, async (t) => {
    try {
      if (await exists(t.file)) {
        skipped++;
        return;
      }
      const res = await fetch(t.url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const svg = await res.text();
      if (!svg.startsWith("<svg")) throw new Error("Not an SVG");
      await fs.writeFile(t.file, svg);
      await removeIfNotSvg(t.file);
      saved++;
    } catch (e) {
      failed++;
      const msg = e instanceof Error ? e.message : String(e);
      logger.warn(`[material-symbols-svg] Failed ${t.url} -> ${t.file}: ${msg}`);
    }
  });
  return { saved, skipped, failed };
}
function defineIcons(symbols, custom, defaults) {
  if (symbolConfig.debug) {
    const symbolCount = Object.keys(symbols || {}).length;
    const customCount = Object.keys(custom || {}).length;
    console.log(`[material-symbols-svg] defineIcons: symbols=${symbolCount}, custom=${customCount}`);
  }
  return {
    Symbols: symbols,
    Custom: custom ?? {},
    Default: defaults ?? {}
  };
}
const IconDefaultConfig = {
  sizes: [20, 24, 40, 48],
  weights: [400],
  fills: [0],
  themes: ["rounded"]
};
async function generateConsumerFiles(ctx, iconsDef, loaderTypesFile, loaderMapFile, distDir) {
  const banner = `// This file is auto-generated by vite-plugin-material-symbols-svg
// Do not edit manually.
`;
  try {
    ctx.warn(`[material-symbols-svg] Generate loader-types.ts`);
    const symKeys = Object.keys(iconsDef.Symbols || {});
    const customKeys = Object.keys(iconsDef.Custom || {});
    const all = Array.from(/* @__PURE__ */ new Set([...symKeys, ...customKeys]));
    const keyUnion = all.length ? all.map((n) => `'${n.replace(/'/g, "\\'")}'`).join(" | ") : "string";
    const typeContent = `${banner}export type IconKey = ${keyUnion};
`;
    await fs.mkdir(distDir, { recursive: true });
    let existing = "";
    try {
      existing = await fs.readFile(loaderTypesFile, "utf-8");
    } catch {
    }
    if (existing !== typeContent) {
      await fs.writeFile(loaderTypesFile, typeContent);
      const now = /* @__PURE__ */ new Date();
      await fs.utimes(loaderTypesFile, now, now).catch(() => {
      });
    }
  } catch (e) {
    const msg = e instanceof Error ? e.message : String(e);
    ctx.warn(`[material-symbols-svg] Failed to write loader-types.ts: ${msg}`);
  }
  try {
    ctx.warn(`[material-symbols-svg] Generate loader-map.js`);
    const imports = [];
    const mapEntries = [];
    const defaults = iconsDef.Default ?? {};
    let i2 = 0;
    for (const [icon, meta] of Object.entries(iconsDef.Symbols || {})) {
      const sizes = normalizeNums(meta.sizes ?? defaults.sizes, IconDefaultConfig.sizes);
      const weights = normalizeNums(meta.weights ?? defaults.weights, IconDefaultConfig.weights);
      const fills = normalizeFills(meta.fills ?? defaults.fills, IconDefaultConfig.fills);
      const themes = normalizeThemes(meta.themes ?? defaults.themes, IconDefaultConfig.themes);
      for (const theme of unique(themes)) {
        for (const weight of unique(weights)) {
          for (const filled of unique(fills)) {
            const key = keyOf({ theme, icon, filled, weight });
            const entries = [];
            for (const size of unique(sizes)) {
              const filename = toFilename(icon, filled, weight, size);
              const importPath = `/symbols/${theme}/${filename}?raw`;
              const varName = `i${i2++}`;
              imports.push(`import ${varName} from '${importPath}';`);
              entries.push(`      ${size}: ${varName}`);
            }
            mapEntries.push(`  '${key}': {
${entries.join(",\n")}
  },`);
          }
        }
      }
    }
    for (const [icon, sizesObj] of Object.entries(iconsDef.Custom || {})) {
      const key = customKeyOf({ icon });
      const entries = [];
      for (const [sizeKey, val] of Object.entries(sizesObj || {})) {
        let value = val;
        if (value && typeof value === "object" && "then" in value && typeof value.then === "function") {
          value = await value;
        }
        if (typeof value === "string" && (value.startsWith("./") || value.startsWith("../"))) {
          const varName = `i${i2++}`;
          imports.push(`import ${varName} from '${value}?raw';`);
          entries.push(`      ${sizeKey}: ${varName}`);
        } else if (value) {
          const content = typeof value === "object" && "default" in value ? value.default : value;
          if (typeof content === "string") {
            entries.push(`      ${sizeKey}: ${JSON.stringify(content)}`);
          }
        }
      }
      if (entries.length) {
        mapEntries.push(`  '${key}': {
${entries.join(",\n")}
  },`);
      }
    }
    const mapContent = `${banner}${imports.join("\n")}

export default {
${mapEntries.join("\n")}
};
`;
    let existing = "";
    try {
      existing = await fs.readFile(loaderMapFile, "utf-8");
    } catch {
    }
    if (existing !== mapContent) {
      await fs.writeFile(loaderMapFile, mapContent);
      const now = /* @__PURE__ */ new Date();
      await fs.utimes(loaderMapFile, now, now).catch(() => {
      });
    }
  } catch (e) {
    const msg = e instanceof Error ? e.message : String(e);
    ctx.warn(`[material-symbols-svg] Failed to write loader-map.js: ${msg}`);
  }
}
async function ensureDir(dir) {
  await fs.mkdir(dir, { recursive: true });
}
function materialSymbolsSvg(iconsDef, opts = {}) {
  const options = {
    concurrency: opts.concurrency ?? 8,
    strict: opts.strict ?? false,
    enabled: opts.enabled ?? true,
    debug: opts.debug ?? (typeof process !== "undefined" && process.env.NODE_ENV !== "production")
  };
  configureSymbolConfig({ debug: options.debug });
  if (!iconsDef || !iconsDef.Symbols) {
    throw new Error("[material-symbols-svg] First parameter must be the return value of defineIcons()");
  }
  let root = "";
  return {
    name: "material-symbols-svg",
    configResolved(config) {
      root = config.root || process.cwd();
    },
    config(config) {
      var _a;
      const symbolsPath = path.resolve(
        root || process.cwd(),
        "node_modules",
        "@hyrioo",
        "vite-plugin-material-symbols-svg",
        ".temp",
        "symbols"
      );
      const alias = ((_a = config.resolve) == null ? void 0 : _a.alias) || {};
      const symbolsAlias = { find: "/symbols", replacement: symbolsPath };
      const newAlias = Array.isArray(alias) ? [...alias, symbolsAlias] : { ...alias, "/symbols": symbolsPath };
      return {
        resolve: {
          alias: newAlias
        }
      };
    },
    async buildStart() {
      if (!options.enabled) return;
      const tempDir = path.resolve(root, "node_modules", "@hyrioo", "vite-plugin-material-symbols-svg", ".temp");
      const outBase = path.resolve(tempDir, "symbols");
      const distDir = path.resolve(root, "node_modules", "@hyrioo", "vite-plugin-material-symbols-svg", "dist");
      const srcPluginDir = path.resolve(root, "node_modules", "@hyrioo", "vite-plugin-material-symbols-svg", "dist", "src", "plugin");
      const srcConsumerDir = path.resolve(root, "node_modules", "@hyrioo", "vite-plugin-material-symbols-svg", "dist", "src", "consumer");
      const versionsFile = path.resolve(tempDir, "versions.json");
      const iconsTsFile = path.resolve(srcPluginDir, "icons.d.ts");
      const loaderTypesFile = path.resolve(srcConsumerDir, "loader-types.d.ts");
      const loaderMapFile = path.resolve(distDir, "loader-map.js");
      await ensureDir(tempDir);
      await fetchVersions(this, versionsFile, iconsTsFile, { strict: options.strict });
      await generateConsumerFiles(this, iconsDef, loaderTypesFile, loaderMapFile, srcConsumerDir);
      const iconsMap = iconsDef.Symbols;
      const defaults = iconsDef.Default ?? {};
      const tasks = [];
      for (const [icon, meta] of Object.entries(iconsMap)) {
        const sizes = normalizeNums(meta.sizes ?? defaults.sizes, IconDefaultConfig.sizes);
        const weights = normalizeNums(meta.weights ?? defaults.weights, IconDefaultConfig.weights);
        const fills = normalizeFills(meta.fills ?? defaults.fills, IconDefaultConfig.fills);
        const themes = normalizeThemes(meta.themes ?? defaults.themes, IconDefaultConfig.themes);
        for (const theme of unique(themes)) {
          await ensureDir(path.resolve(outBase, theme));
          for (const weight of unique(weights)) {
            for (const filled of unique(fills)) {
              for (const size of unique(sizes)) {
                const axes = axesString(weight, filled);
                const url = buildSymbolUrl(theme, icon, axes, size);
                const file = path.resolve(outBase, theme, toFilename(icon, filled, weight, size));
                tasks.push({ url, file });
              }
            }
          }
        }
      }
      this.warn(`[material-symbols-svg] Downloading symbols`);
      const result = await downloadSymbols(tasks, options.concurrency, this);
      const summary = `[material-symbols-svg] Done. Saved: ${result.saved}, Skipped: ${result.skipped}, Failed: ${result.failed}`;
      if (result.failed > 0 && options.strict) this.error(summary);
      else this.info(summary);
    }
  };
}
export {
  configureSymbolConfig,
  defineIcons,
  i as isProduction,
  materialSymbolsSvg,
  symbolConfig
};
//# sourceMappingURL=index.js.map
