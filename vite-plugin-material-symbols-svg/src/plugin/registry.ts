import fs from 'node:fs/promises';
import type { PluginContext } from 'rollup';
import { toFilename } from './symbols';
import {
    type DefineCustomMap,
    type DefinedIcons,
    type Filled,
    type IconConfig,
    type OpticalSize,
    type SymbolKey,
    type SymbolSvg,
    type Theme,
    type Weight,
} from '../shared/types';
import { customKeyOf, keyOf, normalizeFills, normalizeNums, normalizeThemes, unique } from '../shared/utils';
import { MaterialSymbolIcon } from './icons';
import { symbolConfig } from '../shared/config';

export type { OpticalSize, Weight, Filled, Theme, SymbolKey, SymbolSvg, IconConfig, DefinedIcons, DefineCustomMap };

/**
 * defineIcons
 * - symbols: the Material Symbols configuration per icon
 * - custom: optional custom icons map
 * - defaults: optional default config applied to all symbol entries
 */
export function defineIcons<
    S extends Partial<Record<MaterialSymbolIcon, Partial<IconConfig>>>,
    C extends DefineCustomMap = {},
    D extends Partial<IconConfig> = {}
>(
    symbols: S,
    custom: C,
    defaults: D,
): DefinedIcons {
    if (symbolConfig.debug) {
        const symbolCount = Object.keys(symbols || {}).length;
        const customCount = Object.keys(custom || {}).length;
        console.log(`[material-symbols-svg] defineIcons: symbols=${symbolCount}, custom=${customCount}`);
    }

    return {
        Symbols: symbols as any,
        Custom: (custom ?? ({} as C)),
        Default: (defaults ?? ({} as D)),
    } as const;
}

export const IconDefaultConfig = {
    sizes: [20, 24, 40, 48] as const,
    weights: [400] as const,
    fills: [0] as const,
    themes: ['rounded'] as const,
};

export async function generateConsumerFiles(
    ctx: PluginContext,
    iconsDef: DefinedIcons,
    loaderTypesFile: string,
    loaderMapFile: string,
    distDir: string,
) {
    const banner = `// This file is auto-generated by vite-plugin-material-symbols-svg\n// Do not edit manually.\n`;

    // 1. Generate loader-types.ts (IconKey)
    try {
        ctx.warn(`[material-symbols-svg] Generate loader-types.ts`);
        const symKeys = Object.keys(iconsDef.Symbols || {});
        const customKeys = Object.keys(iconsDef.Custom || {});
        const all = Array.from(new Set([...symKeys, ...customKeys]));
        const keyUnion = all.length
            ? all.map((n) => `'${n.replace(/'/g, '\\\'')}'`).join(' | ')
            : 'string';
        const typeContent = `${banner}export type IconKey = ${keyUnion};\n`;

        await fs.mkdir(distDir, {recursive: true});

        let existing = '';
        try {
            existing = await fs.readFile(loaderTypesFile, 'utf-8');
        } catch {
        }

        if (existing !== typeContent) {
            await fs.writeFile(loaderTypesFile, typeContent);
            const now = new Date();
            await fs.utimes(loaderTypesFile, now, now).catch(() => {
            });
        }
    } catch (e) {
        const msg = e instanceof Error ? e.message : String(e);
        ctx.warn(`[material-symbols-svg] Failed to write loader-types.ts: ${msg}`);
    }

    // 2. Generate loader-map.js
    try {
        ctx.warn(`[material-symbols-svg] Generate loader-map.js`);
        const imports: string[] = [];
        const mapEntries: string[] = [];
        const defaults: Partial<IconConfig> = iconsDef.Default ?? {};

        let i = 0;
        for (const [icon, meta] of Object.entries(iconsDef.Symbols || {})) {
            const sizes = normalizeNums((meta.sizes ?? defaults.sizes), IconDefaultConfig.sizes);
            const weights = normalizeNums((meta.weights ?? defaults.weights), IconDefaultConfig.weights);
            const fills = normalizeFills((meta.fills ?? defaults.fills), IconDefaultConfig.fills);
            const themes = normalizeThemes((meta.themes ?? defaults.themes), IconDefaultConfig.themes);

            for (const theme of unique(themes)) {
                for (const weight of unique(weights)) {
                    for (const filled of unique(fills)) {
                        const key = keyOf({ theme, icon, filled, weight } as any);
                        const entries: string[] = [];
                        for (const size of unique(sizes)) {
                            const filename = toFilename(icon, filled as 0 | 1, weight, size);
                            const importPath = `/symbols/${theme}/${filename}?raw`;
                            const varName = `i${i++}`;
                            imports.push(`import ${varName} from '${importPath}';`);
                            entries.push(`      ${size}: ${varName}`);
                        }
                        mapEntries.push(`  '${key}': {\n${entries.join(',\n')}\n  },`);
                    }
                }
            }
        }

        // Add custom icons to the map
        for (const [icon, sizesObj] of Object.entries(iconsDef.Custom || {})) {
            const key = customKeyOf({ icon } as any);
            const entries: string[] = [];
            for (const [sizeKey, val] of Object.entries(sizesObj as any || {})) {
                let value = val;
                if (value && typeof value === 'object' && 'then' in value && typeof (value as any).then === 'function') {
                    value = await value;
                }

                if (typeof value === 'string' && (value.startsWith('./') || value.startsWith('../'))) {
                    const varName = `i${i++}`;
                    imports.push(`import ${varName} from '${value}?raw';`);
                    entries.push(`      ${sizeKey}: ${varName}`);
                } else if (value) {
                    // It's already imported or literal content
                    const content = (typeof value === 'object' && 'default' in value)
                        ? (value as any).default
                        : value;

                    if (typeof content === 'string') {
                        entries.push(`      ${sizeKey}: ${JSON.stringify(content)}`);
                    }
                }
            }
            if (entries.length) {
                mapEntries.push(`  '${key}': {\n${entries.join(',\n')}\n  },`);
            }
        }

        const mapContent = `${banner}${imports.join('\n')}\n\nexport default {\n${mapEntries.join('\n')}\n};\n`;

        let existing = '';
        try {
            existing = await fs.readFile(loaderMapFile, 'utf-8');
        } catch {
        }

        if (existing !== mapContent) {
            await fs.writeFile(loaderMapFile, mapContent);
            const now = new Date();
            await fs.utimes(loaderMapFile, now, now).catch(() => {
            });
        }
    } catch (e) {
        const msg = e instanceof Error ? e.message : String(e);
        ctx.warn(`[material-symbols-svg] Failed to write loader-map.js: ${msg}`);
    }
}
